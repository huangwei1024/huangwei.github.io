---
layout: post
title: 游戏中的随机概率
categories: develop dev-log
tags: game random algorithm
description: 游戏中的随机概率
keywords: 游戏开发，随机，概率，统计，分布，算法
---

这段时间公司开发的游戏上线测试，许多玩家在抽卡时抱怨脸黑，很难抽到所需要的卡牌，而又有一部分玩家反应运气好能连着抽到紫卡，检查了下随机相关逻辑代码，并没有找出问题所在，玩家运气好与坏只是觉得真有可能是概率原因。

测试开服了几天之后，需要开放某个限时抽卡活动，在内部测试时，我们发现玩家反应的问题在限时抽卡中格外明显，尤其是其中最主要的一张稀有卡牌，猜测因为限时抽卡库配置的种类较少，然后就拿该活动来检查了下我们游戏随机机制问题。

<!--more-->

## 5%概率？20次出现一次？

大部分游戏策划使用权值来配置随机概率，因为权值有个好处就是可以在增加随机物品时，可以不对之前的配置进行更改，比如：白卡 30，蓝卡 10，紫卡 10，转为概率即是：白卡 60%，蓝卡 20%，紫卡 20%。

而上述限时抽卡的例子中，我们的权值配置是5和95，模拟50000次随机（使用系统随机函数，如C的rand函数，Python的random库）得到如下结果：

![按权值随机50000次]({{ site.cdn.link }}/static/img/rnd1.jpg)

上图绘制的是权值为5的卡牌的随机状态，红色的图是分布图，X轴是出现的次数，Y轴是相同卡牌再次出现的间隔。绿色的图是分布概率图，X轴是间隔数，Y轴是概率。按策划的想法，**5%概率**应该等同于**20次出现一次**，那上图很明显并不满足**20次出现一次**出现规则，实际间隔从近到远呈下坡形状分布，就是说相邻的概率最大，间隔最大超过160，这与玩家所吐槽的抽卡体验是一致的。但50000次随机总共出现了2508次，从统计的意义上来说又是符合**5%概率**的。所以这个问题，究其原因就是所谓的概率是统计意义上的还是分布意义上的。

## 最原始的实现

我用列表里取元素的方式来模拟**20次出现一次**，为了方便比较异同，直接随机的方式我也贴上相关代码。

```py
pool = [0]*5 + [1]*95
result = [random.choice(a) for i in xrange(N)]
```
上面是直接随机的方式，只保证**5%概率**。

```py
pool = []
result = []
for i in xrange(N):
	if not pool:
		pool = [0]*1 + [1]*19
		random.shuffle(pool)
	result.append(pool[-1])
	del pool[-1]
```
上面是打乱列表，然后依次取元素的方式，保证**20次出现一次**，而**5%概率**则是隐含在内的，生成效果如下图。

![使用第二种实现的随机分布]({{ site.cdn.link }}/static/img/rnd2.png)

眼尖的会发现在第一个实现中我用的pool是`[0]*5 + [1]*95`，而第二个实现中我用的是`[0]*1 + [1]*19`。

这里**20次出现一次**并不等同于**100次出现五次**，也是从分布的意义上来说的，**100次出现五次**是存在5次连续出现的可能。

针对策划的配置，我们需要进行预处理，怎么处理？GCD啊~，5和95的最大公约数是5，所以在第二个实现的代码中我直接使用了1和19。

但这里有个问题，一般策划配置的随机库中肯定有多个物品。权值如果配置的比较随意的话，很可能就导致GCD为1，这样想要实现**XX次出现一次**就不可行了。比如刚才的权值配置5和95，再加一个权值为11的话，就只能实现**111次出现5次**。

所以这两种依赖列表的随机方式并不适用，一是需要维护的列表内存会比较大，二是对策划配置方式有过多约束。

## 更通用更优美的实现

**20次出现一次**是以20为标准周期，当然不能每次都是间隔20出现，这样就太假了，根本没有随机感受可言，为了模拟随机并可以控制一定的出现频率，我选择正态分布来进行伪随机分布生成。

![正态分布]({{ site.cdn.link }}/static/img/rnd3_Normal_distribution.png)

关于正态分布这里就不详细描述了，只需关心分布的两个参数即可，位置参数为$\mu$、尺度参数为$\sigma$。根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%。

![根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%]({{ site.cdn.link }}/static/img/rnd4_normal_sigma.png)

用上面的例子来定下参数，$\mu=20, \sigma=20/3$，这样每次按正态分布随机，就能得到一个理想的随机分布和概率区间。

C语言标准函数库中只有rand，如何生成符合正态分布的随机数可以参见[WiKi上的介绍](https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83)。这里我直接使用Python中random库中的normalvariate函数，当然gauss函数也是一样的，[官方文档](https://docs.python.org/2/library/random.html)上说gauss函数会快些，[StackOverFlow](http://stackoverflow.com/questions/27749133/what-is-the-difference-between-random-normalvariate-and-random-gauss-in-pyth)上说gauss是非线程安全函数，所以会快些。我自己简单测试了下，在单线程情况下，gauss会快些，但只是快了一点点而已。

首先，我直接生成权值为5的卡牌的间隔，检验下正态分布的随机效果。

```py
NN = int(N*0.05)
mu, sigma = 20, 20/3.
delta = [int(random.normalvariate(mu, sigma)) for i in xrange(NN)]
```

![模拟正态分布的伪随机]({{ site.cdn.link }}/static/img/rnd3.png)

OK，接下来就是替换旧的随机算法了。

## 细节和优化



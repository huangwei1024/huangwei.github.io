---
layout: post
title: 游戏中的随机概率
categories: develop dev-log
tags: game random algorithm
description: 游戏中的随机概率
keywords: 游戏开发，随机，概率，统计，分布，算法
---

这段时间公司开发的游戏上线测试，许多玩家在抽卡时抱怨脸黑，很难抽到所需要的卡牌，而又有一部分玩家反应运气好能连着抽到紫卡，检查了下随机相关逻辑代码，并没有找出问题所在，玩家运气好与坏只是觉得真有可能是概率原因。

测试开服了几天之后，需要开放某个限时抽卡活动，在内部测试时，我们发现玩家反应的问题在限时抽卡中格外明显，尤其是其中最主要的一张稀有卡牌，猜测因为限时抽卡库配置的种类较少，然后就拿该活动来检查了下我们游戏随机机制问题。

<!--more-->

## 5%概率？20次出现一次？

大部分游戏策划使用权值来配置随机概率，因为权值有个好处就是可以在增加随机物品时，可以不对之前的配置进行更改，比如：白卡 30，蓝卡 10，紫卡 10，转为概率即是：白卡 60%，蓝卡 20%，紫卡 20%。

而上述限时抽卡的例子中，我们的权值配置是5和95，模拟50000次随机（使用系统随机函数，如C的rand函数，Python的random库）得到如下结果：

<p align="center">
![按权值随机50000次]({{ site.cdn.link }}/static/img/rnd1.jpg)
</p>

上图绘制的是权值为5的卡牌的随机状态，红色的图是分布图，X轴是出现的次数，Y轴是相同卡牌再次出现的间隔。绿色的图是分布概率图，X轴是间隔数，Y轴是概率。按策划的想法，**5%概率**应该等同于**20次出现一次**，那上图很明显并不满足**20次出现一次**出现规则，但50000次随机总共出现了2508次，从统计的意义上来说又是符合**5%概率**的。所以这个问题，究其原因就是所谓的概率是统计意义上的还是分布意义上的。

## 最原始的实现

我用列表里取元素的方式来模拟**20次出现一次**，为了方便比较异同，直接随机的方式我也贴上相关代码。

```py
pool = [0]*5 + [1]*95
result = [random.choice(a) for i in xrange(N)]
```
上面是直接随机的方式，只保证**5%概率**。

```py
pool = []
result = []
for i in xrange(N):
	if not pool:
		pool = [0]*1 + [1]*19
		random.shuffle(pool)
	result.append(pool[-1])
	del pool[-1]
```
上面是打乱列表，然后依次取元素的方式，保证**20次出现一次**，而**5%概率**则是隐含在内的。

眼尖的会发现在第一个实现中我用的pool是`[0]*5 + [1]*95`，而第二个实现中我用的是`[0]*1 + [1]*19`。

这里**20次出现一次**并不等同于**100次出现五次**，也是从分布的意义上来说的，**100次出现五次**是存在5次连续出现的可能。

针对策划的配置，我们需要进行预处理，怎么处理？GCD啊~，5和95的最大公约数是5，所以在第二个实现的代码中我直接使用了1和19。

但这里有个问题，一般策划配置的随机库中肯定有多个物品。

## 更通用更优美的实现

**20次出现一次**是以20为标准周期，当然不能每次都是间隔20出现，这样就太假了，根本没有随机感受可言，为了模拟随机并可以控制一定的出现频率，我选择正态分布来进行伪随机分布生成。

<p align="center">
![正态分布](./static/img/rnd3_Normal_distribution.png)
</p>

关于正态分布这里就不详细描述了，只需关心分布的两个参数即可，位置参数为$\mu$、尺度参数为$\sigma$。根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%。

<p align="center">
![根据正态分布，两个标准差之内的比率合起来为95%；三个标准差之内的比率合起来为99%]({{ site.cdn.link }}/static/img/rnd4_normal_sigma.png)
</p>

用上面的例子来定下参数，$\mu=20, \sigma=20/3$，这样
